// 19. 프로토타입
//     클래스, 생성자 함수 모두 '프로토타입' 기반의 인스턴스를 생성하지만 정확히 동일하지는 않음
//     클래스 기능(엄격) > 생성자 함수

// 19.1 객체지향 프로그래밍
//     1) 전통적인 '명령형 프로그래밍' -> 객체의 집합으로 프로그램을 표현하는 '객체지향 프로그래밍'
//     2) 객체지향 프로그래밍에서의 객체 : 상태(프로퍼티) 데이터와 동작(메서드)을 하나의 논리적으로 묶은 복합적인 자료구조
//     3) 각 객체는 '고유의 기능'을 갖는 독립적인 부품일수도, 다른 객체와 '메세지나 데이터'를 주고받고 처리할 수 있음. 상속받기도 함

// 19.2 상속과 프로토타입
//     '상속'은 객체지향 프로그래밍의 핵심 개념
//     1) 상속 : 어떤 객체의 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
//         이는 '프로토타입'을 기반으로 구현되며, 불필요한 중복을 제거함(메모리 낭비 방지)
//         -> 기존 코드 적극적 재사용 -> 개발 비용을 현저히 줄임

//         프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.

// 19.3 프로토타입 객체(줄여서 프로토타입)
//     프로토타입 : 객체 간 상속을 구현하기 위해 사용되는 객체
//         프로토타입을 '상속받은' 하위 객체는 상위 객체의 프로퍼티를 '자신의 프로퍼티'처럼 자요롭게 사용할 수 있다.
//         (주의 : 실제 자신의 프로퍼티가 아니며, 생상자 함수의 prototype에 '바인딩'되어 있는 것)
//         생성자 함수와 그에 대응하는 프로토타입은 '한 쌍'

// 19.4 __proto__ 접근자 프로퍼티
//     1) 객체 속 __proto__ => 그 객체의 프로토타입(상속받은 거겠지)인 Object.prototype임
//         __proto__ 접근자 프로퍼티 => 이 객체의 [[Prototype]] 내부 슬롯이 가리키는 객체인 Object.prototype에 접근한 결과
//     2) __proto__ 접근자 프로퍼티의 프로퍼티 어트리뷰트
//         [[Get]] : __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근 시 호출
//         [[Set]] : __proto__ 접근자 프로퍼티를 통해 새로운 프로퍼티를 할당하면 호출
//     3) 해당 객체가 직접 소유하는 프로퍼티 아님(위에 언급)
//         const example = {name:"Kim"}
//         console.log(example.getOwnPropertyDescriptor("__proto__"))
//         false임
//     4) 모든 객체는 프로토타입 계층 구조인 '프로토타입 체인'에 묶여있다.
//         이 접근자 프로퍼티를 사용하면 에러를 통해 '상호 참조'에 의한 프로토타입 체인이 생성되지 않도록 한다.
//         const parent = {};
//         const children = {};
//         parent.__proto__ = children;
//         children.__proto__ = parent;
//     5) 되도록이면 코드 내에서 __proto__ 접근자 프로퍼티의 사용은 권장하지 않음.
//     6) __proto__ 접근자 프로퍼티 vs prototype 프로퍼티
//         소유 : 모든 객체 vs constructor
//         사용 주체 : 모든 객체 vs 생성자 함수
//         목적 : 객체가 자신의 프로토타입의 접근, 교체 위해 사용
//                 vs 자신이 '생성할' 객체 인스턴스의 프로토타입을 할당하기 위해 사용
//         생성자.prototype === 인스턴스.__proto__

//     7) constructor
//         모든 프로토타입은 constructor 프로퍼티를 가짐
//         이 constructor 프로퍼티의 값(가리키는 것) : 자신을 참조하는 생성자 함수
//         인스턴스.constructor === 생성자

// 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
//     객체 리터럴 -> 내부 알고리즘으로 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성
//     즉, 프로토타입과 생성자 함수는 언제나 '쌍'으로 존재. 단독으로 존재할 수 없음
//     1) 객체 리터럴 : Object - Object.prototype
//     2) 함수 리터럴 : Function - Function.prototype
//     3) 배열 리터럴 : Array - Array.prototype
//     4) 정규 표현식 리터럴 : RegExp - RegExp.prototype

// 19.5 프로토타입의 생성 시점
//     결국 모든 객체는 생성자 함수와 연결됨
//     프로토타입 생성 시점 : 생성자 함수가 '생성되는 시점'에 더불어 생성(그래서 언제나 '쌍'으로 존재할 수 밖에 없음)
//         1) 사용자 정의 생성자 함수(constructor) : 함수 '정의'가 '평가'되어 '함수 객체를 생성'하는 시점에 프로토타입 생성(호이스팅)
//             생성된 프로토타입은 오직 constructor만 가지며, 자신의 프로토타입은 언제나 Object.prototype이다
//         2) 빌트인 생성자 함수 : 빌트인 생성자 함수가 '생성'되는 시점. 전역 객체가 생성되는 시점(코드 실행 이전)에 생성

// 19.6 객체 생성 방식과 프로토타입의 결정
//     객체 생성 방법 : 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)
//     1) 공통점 : 추상 연산 OrdinaryObjectCreate에 의해 생성된다
//         추상 연산 OrdinaryObjectCreate
//             - 필수적으로 자신이 생성할 객체의 '프로토타입'을 인수로 전달받음
//             - 자신이 생성할 객체의 추가할 프로퍼티 목록을 전달(옵션)
//             - 순서 : 빈 객체 생성
//                 -> 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우 객체에 이를 추가
//                 -> 인수로 전달받은 '프로토타입'을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당
//                 -> 생성한 객체를 반환
//     2) 차이점
//         - 객체 리터럴, Object 생성자 함수 : 프로토타입이 Object.prototype 임
//         - 생성자 함수 : 프로토타입이 생성자 함수 prototype 프로퍼티애 바인딩되어 있는 객체

// 19.7 프로토타입 체인(상속과 프로퍼티 검색을 위한 메커니즘)
//     객체의 프로퍼티(메서드 포함)에 접근하려 할 때 해당 객체에 접근하려 하는 프로퍼티 없다면
//     -> [[Prototype]] 내부 슬롯 따라 부모 프로토타입 탐색(순차적으로 상위로)
//     -> 최상위 Object.prototype 탐색
//     (주의 : 스코프 체인은 식별자 검색을 위함 메커니즘이다)

// 19.8 오버라이딩과 프로퍼티 새도잉
//     프로퍼티 섀도잉 : 인스턴스에 프로토타입의 프로퍼티와 같은 이름의 프로퍼티를 추가하면(오버라이딩), 프로토타입 프로퍼티를 덮어쓰는 것이 아니라
//         인스턴스 프로퍼티로 추가한다. 이 때 상속 관계에 의해 프로토타입의 프로퍼티가 가려진다(프로퍼티 새도잉).
//     1) 추가 -> 오버라이딩 -> 섀도잉
//     2) 제거 -> 인스턴스만 제거 가능. prototype의 프로퍼티는 인스턴스에서 제거 불가(set 엑세스 허용 안함)
//         const Person = (function() {
//         function Person(name) {
//             this.name=name;
//         }
//         Person.prototype.sayHello = function (){
//             console.log(`Hi my name is ${this.name}`)
//         }
//         return Person;
//     }());
//     const me = new Person("Lee")

//     me.sayHello = function(){
//         console.log(`Hey My name is ${this.name}`)
//     }
//     me.sayHello();

// 19.9 프로토타입의 교체(직접 하는 것은 비추)
//     1) 생성자 함수에 의한 프로토타입의 교체(미래에 생성할 인스턴스의 프로토타입을 변경하는 것)
//         - 방법
//         생성자 함수.prototype={
//             어쩌구저쩌구
//         }
//         - 주의 : constructor 프로퍼티가 교체된 프로토타입에는 없으므로,
//             이 생성자 함수로 생성된 인스턴스의 constructor는 Object이다.
//             -> 이를 해결하려면 교체할 프로토타입에 constructor를 추가하자
//     2) 인스턴스에 의한 프로토타입의 교체(이미 생성된 객체의 프로토타입을 교체하는 것)
//         - 방법(__proto__ 접근자 프로퍼티 사용됨)
//         Object.setPrototypeOf(객체, 변경할 프로토타입 역할을 하는 객체);

//     중요) 생성자 함수에 의해 : 프로토타입이 교체되고 생성된 '인스턴스'와 '생성자 함수' 간의 constructor 연결이 안되있음. 연결 필요
//          인스턴스에 의해 : 교체된 '프로토타입'이 생성자 함수와 prototype으로 연결되지 않음. 연결 필요
//          -> 직접 이렇게 교체하는 것은 비추천. '직접 상속', '클래스'를 활용하자.

// 19.10 instanceof 연산자
//     1) 사용 방법 : 객체 instanceof 생성자 '함수'
//     2) 평가 : 생성자 함수의 prototype에 바인딩된 객체 중 좌변 객체의 '프로토타입 체인' 상에 존재하면 true
//         - constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아님

// 19.11 직접 상속
//     1) Object.create에 의한 직접 상속 : 300페이지 참조
//     2) 객체 리터럴 내부에서 __proto__에 의한 직접 상속
//         __proto__ : 프로토타입 객체

// 19.12 정적 프로퍼티/메서드
//     1) 정의 : 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드
//     2) 생성 방법
//         - 생성자 함수 생성 후 : 생성자함수.ㅇㄹㅇㄹ = 프로퍼티 혹은 메서드
//         - 생성자 함수 생성 중 : 생성자 함수 블록 내부에 this를 참조하지 않도록 작성
//     3) 주의 : 이 생성자 함수로 생성된 인스턴스는 정적 프로퍼티/메서드를 호출할 수 없다
//         - 프로토타입 체인에 포함되지 않기 때문에

// 19.13 프로퍼티 존재 확인 -> boolean 값
//     1) in 연산자 : key in object
//         object는 상속받은 모든 프로토타입의 프로퍼티를 확인함. 주의
//     2) (ES6) Reflect.has(object, key) : in 연산자와 동일하게 작동
//     3) Object.prototype.hasOwnProperty : 객체 '고유의' 프로퍼티 키인 경우만 true
//         프로토타입의 프로퍼티 키인 경우도 false임(1,2와 다른 점)

// 19.14 프로퍼티 열거
//     1) for...in 문: for (변수 선언문 in 객체) {..}
//         변수 선언문은 key값 할당받음
//         주의 - 프로토타입 프로퍼티까지 열거하되, [[Enumerable]]이 true인 프로퍼티만 열거함
//             - 프로퍼티 키가 Symbol인 프로퍼티는 열거하지 않음
//             - 순서는 보장하지 않을수도
//             - 베열은 이 방법이 아니라 일반적인 'for문'이나 'for...of문' 또는 Array.prototype.forEach 메서드 사용 권장
//     2) Object.keys/values/entries 메서드
//         '객체 자신의 고유 프로퍼티'만 '열거'하기 위해서는 위 방법보다 권장한다.
//         - Object.keys(객체) : key들만 배열 형태로 반환
//         - Object.values(객체) : value들만 배열 형태로 반환
//         - Object.entries(객체) : 프로퍼티의 키와 값의 '쌍'의 배열을 배열에 담아 반환
