19. 프로토타입
    클래스, 생성자 함수 모두 '프로토타입' 기반의 인스턴스를 생성하지만 정확히 동일하지는 않음
    클래스 기능(엄격) > 생성자 함수

19.1 객체지향 프로그래밍
    1) 전통적인 '명령형 프로그래밍' -> 객체의 집합으로 프로그램을 표현하는 '객체지향 프로그래밍'
    2) 객체지향 프로그래밍에서의 객체 : 상태(프로퍼티) 데이터와 동작(메서드)을 하나의 논리적으로 묶은 복합적인 자료구조
    3) 각 객체는 '고유의 기능'을 갖는 독립적인 부품일수도, 다른 객체와 '메세지나 데이터'를 주고받고 처리할 수 있음. 상속받기도 함

19.2 상속과 프로토타입
    '상속'은 객체지향 프로그래밍의 핵심 개념
    1) 상속 : 어떤 객체의 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
        이는 '프로토타입'을 기반으로 구현되며, 불필요한 중복을 제거함(메모리 낭비 방지)
        -> 기존 코드 적극적 재사용 -> 개발 비용을 현저히 줄임
        
        프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.

19.3 프로토타입 객체(줄여서 프로토타입)
    프로토타입 : 객체 간 상속을 구현하기 위해 사용되는 객체
        프로토타입을 '상속받은' 하위 객체는 상위 객체의 프로퍼티를 '자신의 프로퍼티'처럼 자요롭게 사용할 수 있다.
        (주의 : 실제 자신의 프로퍼티가 아니며, 생상자 함수의 prototype에 '바인딩'되어 있는 것)
        생성자 함수와 그에 대응하는 프로토타입은 '한 쌍'     

19.4 __proto__ 접근자 프로퍼티
    1) 객체 속 __proto__ => 그 객체의 프로토타입(상속받은 거겠지)인 Object.prototype임
        __proto__ 접근자 프로퍼티 => 이 객체의 [[Prototype]] 내부 슬롯이 가리키는 객체인 Object.prototype에 접근한 결과
    2) __proto__ 접근자 프로퍼티의 프로퍼티 어트리뷰트 
        [[Get]] : __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근 시 호출
        [[Set]] : __proto__ 접근자 프로퍼티를 통해 새로운 프로퍼티를 할당하면 호출
    3) 해당 객체가 직접 소유하는 프로퍼티 아님(위에 언급)
        const example = {name:"Kim"}
        console.log(example.getOwnPropertyDescriptor("__proto__")) 
        false임
    4) 모든 객체는 프로토타입 계층 구조인 '프로토타입 체인'에 묶여있다.
        이 접근자 프로퍼티를 사용하면 에러를 통해 '상호 참조'에 의한 프로토타입 체인이 생성되지 않도록 한다.
        const parent = {};
        const children = {};
        parent.__proto__ = children;
        children.__proto__ = parent;
    5) 되도록이면 코드 내에서 __proto__ 접근자 프로퍼티의 사용은 권장하지 않음.
    6) __proto__ 접근자 프로퍼티 vs prototype 프로퍼티
        소유 : 모든 객체 vs constructor
        사용 주체 : 모든 객체 vs 생성자 함수
        목적 : 객체가 자신의 프로토타입의 접근, 교체 위해 사용 
                vs 자신이 '생성할' 객체 인스턴스의 프로토타입을 할당하기 위해 사용
        생성자.prototype === 인스턴스.__proto__
    
    7) constructor
        모든 프로토타입은 constructor 프로퍼티를 가짐
        이 constructor 프로퍼티의 값(가리키는 것) : 자신을 참조하는 생성자 함수
        인스턴스.constructor === 생성자

19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
    객체 리터럴 -> 내부 알고리즘으로 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성
    즉, 프로토타입과 생성자 함수는 언제나 '쌍'으로 존재. 단독으로 존재할 수 없음
    1) 객체 리터럴 : Object - Object.prototype
    2) 함수 리터럴 : Function - Function.prototype
    3) 배열 리터럴 : Array - Array.prototype
    4) 정규 표현식 리터럴 : RegExp - RegExp.prototype

19.5 프로토타입의 생성 시점
    결국 모든 객체는 생성자 함수와 연결됨
    프로토타입 생성 시점 : 생성자 함수가 '생성되는 시점'에 더불어 생성(그래서 언제나 '쌍'으로 존재할 수 밖에 없음)
        1) 사용자 정의 생성자 함수(constructor) : 함수 '정의'가 '평가'되어 '함수 객체를 생성'하는 시점에 프로토타입 생성(호이스팅)
            생성된 프로토타입은 오직 constructor만 가지며, 자신의 프로토타입은 언제나 Object.prototype이다
        2) 빌트인 생성자 함수 : 빌트인 생성자 함수가 '생성'되는 시점. 전역 객체가 생성되는 시점(코드 실행 이전)에 생성
            